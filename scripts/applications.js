/**
 * Interactively manage Cisco Webex Teams applications (or use require)
 */
const fs = require('fs')
const os = require('os')
const path = require('path')
const querystring = require('querystring')
const url = require('url')

const chalk = require('chalk')
const debug = require('debug')
const fetch = require('node-fetch')
const inquirer = require('inquirer')
const JWT = require('jsonwebtoken')
const _ = require('lodash')

const log = Object.freeze({
	debug: debug('cisco-webex-tools:webex-teams-applications'), // better name?
	error: (...args) => console.error(...args), // eslint-disable-line no-console
})

const loadAccessToken = () => {
	try {
		const secretsJSON = path.resolve(os.homedir(), '.cisco-webex-tools', 'secrets.json')
		return _.get(JSON.parse(fs.readFileSync(secretsJSON)), 'authorization.access_token')
	} catch (error) {
		log.error(error)
		return '' // ew
	}
}

// default file name (JSON) is generated by calling these functions with no arguments
const currentDateName = (date = new Date()) => date.toISOString().replace(/[.:\-\s]/g, '_')
const generateFileName = (prefix = currentDateName(), suffix = '.json') => `${prefix}${suffix}`

const saveCreatedApplication = (json, file = generateFileName()) => {
	try {
		const source = JSON.stringify(json, null, '\t')
		const target = path.resolve(__dirname, file)
		fs.writeFileSync(target, source + os.EOL)
		log.debug('saved to: %s', target)
	} catch (error) {
		// should dump JSON?
		log.error(error)
		throw error
	}
}

// N.B. the following references the old name for Cisco Webex Teams: "Spark"
const DEFAULT_ACCESS_TOKEN = process.env.CISCOSPARK_ACCESS_TOKEN || loadAccessToken()
const DEFAULT_ORIGIN_URL = process.env.CISCOSPARK_ORIGIN_URL || 'https://api.ciscospark.com'
const buildURL = (string, origin = DEFAULT_ORIGIN_URL) => new url.URL(string, origin).toString()
const capitalizeString = (any = '') => String(any).replace(/^./, prefix => prefix.toLocaleUpperCase())
const matchingStrings = (lhs, rhs) => String(lhs).toLocaleLowerCase() === String(rhs).toLocaleLowerCase()
const devURL = buildURL('/getting-started.html#authentication', 'https://developer.webex.com')
//const docURL = buildURL('/', 'https://developer.webex.com') // anything more specific?

const botEmailDomain = process.env.BOT_DOMAIN_NAME || 'webex.bot' // was formerly @sparkbot.io
const httpPortNumber = Number(process.env.PORT) || 8080 // could use config.get('server.port')
const jwtFeatureName = 'Guest Issuer' // managed via /v1/jwt, not via /v1/applications
const prompt = inquirer.createPromptModule()
const askAccessToken = Object.freeze({
	default: DEFAULT_ACCESS_TOKEN,
	message: 'Access Token:',
	name: 'token',
	prefix: chalk.bold(chalk.red('#')),
	suffix: ` (see: ${devURL})`,
	type: 'password',
	validate: answer => answer.length > 0,
})

const fetchCWT = async (resourceURI, requestOptions = {}) => {
	const headers = Object.assign({}, requestOptions.headers) // token?
	const request = Object.assign({ method: 'GET' }, requestOptions)
	request.url = buildURL(resourceURI, request.url)
	request.headers = new fetch.Headers(headers)
	if (typeof request.body === 'object') {
		request.headers.set('content-type', 'application/json')
		request.body = JSON.stringify(request.body)
	}
	const hrtime = process.hrtime()
	const response = await fetch(request.url, request).catch(error => error)
	response.tracking = response.message || response.headers.get('trackingid')
	const [s, ns] = process.hrtime(hrtime)
	const ms = Number(s * 1e3 + ns / 1e6)
	log.debug('fetch ~ %sms: %s %s => %d %s (tracking ID: %s)',
		ms.toFixed(),
		request.method,
		request.url,
		response.status,
		response.statusText,
		response.tracking,
	)
	if (response instanceof Error) throw response // ew
	if (!response.ok) throw new Error(await response.text())
	if (response.status === 204) {
		return Object.freeze({
			headers: response.headers.raw(),
		})
	}
	return Object.freeze({
		body: await response.json(),
		headers: response.headers.raw(),
	})
}

const validateAccessToken = async (token, getURL = buildURL('/v1/people/me')) => {
	if (!token) throw new Error(`failed GET ${getURL} (missing access token)`)
	try {
		const authorization = `Bearer ${token}`
		const { body } = await fetchCWT(getURL, {
			headers: { authorization },
		})
		return body
	} catch (error) {
		log.error(error)
		throw new Error(`failed GET ${getURL} (invalid access token)`)
	}
}

const loginOrApplication = async (token, id, secret) => {
	if (secret) {
		const jwtClaims = {
			iss: id,
			name: 'Echo',
			sub: 'echo',
		}
		const jwtOptions = {
			expiresIn: '1d',
		}
		const jwtToken = JWT.sign(jwtClaims, Buffer.from(secret, 'base64'), jwtOptions)
		const authorization = `Bearer ${jwtToken}` // no need for token?
		const { body } = await fetchCWT('/v1/jwt/login', {
			headers: { authorization },
			method: 'POST',
		})
		return body
	}
	if (!token) throw new Error('failed to fetch (missing access token)')
	const authorization = `Bearer ${token}` // same as validate?
	const isJWT = _.size(id) === 87 // XXX: this is a dumb hack
	if (isJWT) {
		const { body } = await fetchCWT(`/v1/jwt/${id}`, {
			headers: { authorization },
		})
		return _.set(body, 'type', jwtFeatureName)
	}
	const { body } = await fetchCWT(`/v1/applications/${id}`, {
		headers: { authorization },
	})
	return _.set(body, 'type', capitalizeString(body.type))
}

const createApplication = async (token = DEFAULT_ACCESS_TOKEN, ...args) => {
	if (!token) throw new Error('failed to create (missing access token)')
	const rw = (...all) => {
		const special = ['spark:all', 'spark:people_read'] // people is read-only for most non-admin(s)
		return special.concat(all.map(any => `spark:${any}_read`), all.map(any => `spark:${any}_write`))
	}
	const determined = Object.assign({}, ...args) // can specify save:Boolean and type:String
	// TODO (tohagema): need to add description for all of these somehow; key-value:Object/Map?
	const permissions = new Set(rw('memberships', 'messages', 'rooms', 'teams')) // can read/write
	const allApplicationTypes = new Set(['bot', 'integration']) // + jwt is special case (see below)
	const defaultApplicationType = determined.type || Array.from(allApplicationTypes).shift() // bot
	const matchesApplicationType = s => ({ type: t = defaultApplicationType }) => matchingStrings(s, t)
	const isJWT = matchesApplicationType(jwtFeatureName) // does not use POST /v1/applications (yet)
	const questions = Object.freeze([
		{
			choices: Array.from(allApplicationTypes, capitalizeString).concat(jwtFeatureName),
			default: capitalizeString(defaultApplicationType), // first (bot) if not defaulted
			message: 'Type of application to create',
			name: 'type',
			prefix: chalk.bold(chalk.blue('?')),
			suffix: ' (default: a robot user, with an email address as identity)',
			type: 'list',
			when: !determined.type || !allApplicationTypes.has(determined.type),
		},
		{
			default: `default.alias@${botEmailDomain}`,
			message: 'Email alias to include your bot in spaces',
			name: 'botEmail',
			prefix: chalk.bold(chalk.yellow('!')),
			suffix: ` (cannot change; must end with: @${botEmailDomain})`,
			validate: answer => answer.endsWith(`@${botEmailDomain}`),
			when: matchesApplicationType('bot'),
		},
		{
			default: 'Bot Name',
			message: 'Display name(s) to mention your bot in messages',
			name: 'name',
			prefix: chalk.bold(chalk.blue('!')),
			suffix: ' (this can be changed later, like any human name)',
			validate: answer => answer.length > 0 && answer.length < 100,
			when: matchesApplicationType('bot'),
		},
		{
			default: 'Integration Name',
			message: 'OAuth2 client name',
			name: 'name',
			prefix: chalk.bold(chalk.yellow('!')),
			suffix: ' (printed on grant page; identifies integration)',
			validate: answer => answer.length > 0 && answer.length < 100,
			when: matchesApplicationType('integration'),
		},
		{
			default: 'Connects stuff together.',
			message: 'Short description/example',
			name: 'description',
			prefix: chalk.bold(chalk.blue('!')),
			suffix: ' (cannot be empty; under 1000 characters)',
			validate: answer => answer.length > 0 && answer.length < 1000,
			when: matchesApplicationType('integration'),
		},
		{
			choices: Array.from(permissions.keys()).sort(),
			message: 'OAuth2 scope required',
			name: 'scopes',
			prefix: chalk.bold(chalk.red('!')),
			suffix: ' (requested; later changes have consequences)',
			type: 'checkbox',
			when: matchesApplicationType('integration'),
		},
		{
			default: buildURL('/', `http://localhost:${httpPortNumber}`),
			message: 'OAuth2 redirect URL(s)',
			name: 'redirectUrls',
			prefix: chalk.bold(chalk.red('!')),
			suffix: ' (whitelist; later changes have consequences)',
			validate: answer => answer.startsWith('http'),
			when: matchesApplicationType('integration'),
		},
		{
			default: 'Issuer Name',
			message: 'JWT issuer alias',
			name: `${jwtFeatureName} Name`,
			prefix: chalk.bold(chalk.blue('!')),
			suffix: ' (for internal use only; might not be unique)',
			when: isJWT,
		},
		{
			message: 'Save the response JSON to disk?',
			name: 'save',
			type: 'confirm',
			when: typeof determined.save !== 'boolean',
		},
	])
	const answers = Object.assign({}, determined, await prompt(questions))
	const authorization = `Bearer ${token}` // request header, for POST
	if (isJWT(answers)) {
		const name = _.get(answers, `${jwtFeatureName} Name`)
		const { body } = await fetchCWT('/v1/jwt', {
			body: { name },
			headers: { authorization },
			method: 'POST',
		})
		if (answers.save) saveCreatedApplication(body)
		return _.set(body, 'type', jwtFeatureName)
	}
	const application = _.omit(answers, ['save', 'type'])
	const type = answers.type.toLowerCase() // is bot or:
	if (type === 'integration') {
		application.redirectUrls = [application.redirectUrls]
	}
	const { body } = await fetchCWT('/v1/applications', {
		body: Object.assign({ type }, application),
		headers: { authorization },
		method: 'POST',
	})
	if (answers.save) saveCreatedApplication(body)
	return body
}

const deleteApplication = async (token, { id, type }) => {
	if (!token) throw new Error('failed to delete (missing access token)')
	const authorization = `Bearer ${token}`
	if (!type || type === jwtFeatureName) {
		await fetchCWT(`/v1/jwt/${id}`, {
			headers: { authorization },
			method: 'DELETE',
		})
	} else {
		await fetchCWT(`/v1/applications/${id}`, {
			headers: { authorization },
			method: 'DELETE',
		})
	}
}

const createdDate = ({ created }) => created ? new Date(created) : new Date() // default: now
const MOST_RECENTLY_CREATED_FIRST = (lhs, rhs) => Math.sign(createdDate(rhs) - createdDate(lhs))

//const delta = (lhs, rhs, key) => _.get(lhs, key, '').localeCompare(_.get(rhs, key, '')) // default: 0
//const sorta = (lhs, rhs) => delta(lhs, rhs, 'type') || delta(lhs, rhs, 'name') || delta(lhs, rhs, 'id'))

const listApplications = async (token = DEFAULT_ACCESS_TOKEN) => {
	if (!token) throw new Error('failed to list (missing access token)')
	const query = querystring.stringify({ createdBy: 'me', waitForCI: 'false' })
	const options = { headers: { authorization: `Bearer ${token}` } } // to fetch list
	const { body } = await fetchCWT(`/v1/applications?${query}`, options) // have a type
	const { body: justGuestIssuers } = await fetchCWT('/v1/jwt', options) // have no type
	const some = justGuestIssuers.items.map(item => _.set(item, 'type', jwtFeatureName)) // dumb hacks:
	const all = [].concat(body.items, some).map(item => _.set(item, 'type', capitalizeString(item.type)))
	return all.sort(MOST_RECENTLY_CREATED_FIRST) // the "sorta" order groups same type, then by name/id
}

const walkApplications = async (token = DEFAULT_ACCESS_TOKEN) => {
	if (!token) throw new Error('failed to walk (missing access token)')
	const sortChoices = (object, order = MOST_RECENTLY_CREATED_FIRST) => {
		const sortEntries = (lhs, rhs) => order(lhs[1], rhs[1]) // by value
		return Object.entries(object).sort(sortEntries).map(any => any[0])
	}
	const toChoice = ({ created, id, name, type = jwtFeatureName }) => {
		const [prefix, suffix] = [capitalizeString(type), name] // meaningful order
		return `${prefix}: ${suffix} (created: ${created}, id: ${id})` // uniqueness
	}
	const before = await listApplications(token)
	const choices = _.keyBy(before, toChoice)
	const { chosen, create } = await prompt([
		{
			choices: sortChoices(choices), // newest to oldest
			message: 'Which application(s) should be deleted?',
			name: 'chosen',
			type: 'checkbox',
		},
		{
			default: false,
			message: 'After that, do you want to create one?',
			name: 'create',
			type: 'confirm',
		},
	])
	const deleted = Object.values(_.pick(choices, chosen)) // some
	for (const one of deleted) await deleteApplication(token, one)
	const created = create ? [await createApplication(token)] : []
	const after = await listApplications(token)
	return {
		after,
		before,
		created,
		deleted,
	}
}

module.exports = {
	createApplication,
	//deleteApplication,
	//listApplications,
	loadAccessToken,
	saveCreatedApplication,
	//walkApplications,
}

if (!module.parent) {
	const buildTable = (items, columns) => {
		const rows = [] // of String[]'s
		const toString = any => String(any || '')
		const max = columns.map(column => column.length)
		for (let i = 0, n = items.length; i < n; i += 1) {
			const all = _.pick(items[i], columns)
			if (_.size(all) === 0) continue // skip
			const strings = Object.values(all).map(toString)
			for (let j = 0, m = max.length; j < m; j += 1) {
				max[j] = Math.max(max[j], strings[j].length)
			}
			rows.push(strings)
		}
		if (rows.length === 0) return []
		const pad = (any, index) => String(any || '').padEnd(max[index], ' ') // with spaces
		const bar = all => ['| ', ' |'].join(all.map(pad).join(' | ')) // with pipes and spaces
		const head = bar(columns) // printed bold at top between dash x2, rows, then dash x1
		const dash = '-'.repeat(head.length) // could make this a little more neat
		return [].concat(dash, chalk.bold(head), dash, rows.map(bar), dash)
	}
	const beforeCommand = (token, command) => {
		if (command === 'create' || command === 'delete') return
		log.error()
		log.error(chalk.bold('\tFetching applications... (may take several seconds)'))
		log.error()
	}
	const afterCommand = (result, tabulate = process.stdout.isTTY) => {
		const items = _.get(result, 'items', [])
		const columns = ['type', 'name', 'id']
		/* eslint-disable no-console */
		if (!tabulate) console.log(JSON.stringify(result || { items }, null, '\t'))
		else for (const string of buildTable(items, columns)) console.log(string)
		/* eslint-enable no-console */
	}
	const confirmDELETE = async (token, id) => {
		const body = await loginOrApplication(token, id) // will fetch JSON
		const message = `Are you sure you want to delete ${body.type}: ${id}?`
		const question = { default: false, message, name: id, type: 'confirm' }
		const answers = await prompt([question]) // user confirmed delete
		if (answers[question.name]) await deleteApplication(token, body)
		return body
	}
	const settlePromises = async (args, visitor) => {
		const promises = []
		for (const one of args) {
			const schedule = async () => visitor(one) // runs in exclusion
			const capture = async error => error // will never throw/reject
			promises.push(Promise.all(promises).then(schedule).catch(capture))
		}
		return Promise.all(promises)
			.then((all) => {
				const [negative, positive] = _.partition(all, one => one instanceof Error)
				for (const one of negative) {
					log.error('[WARNING] operation failed:', one.message)
				}
				if (all.length !== positive.length) {
					log.error('[WARNING] some operation(s) failed; attempt re-run with DEBUG=*')
				}
				return positive
			})
	}
	const runCommand = async (token, command, ...args) => {
		while (!token) {
			// TODO: auth flow? or use credentials/grant?
			const question = askAccessToken // Object
			const answer = await prompt([question])
			try {
				token = _.get(answer, question.name) // String
				const person = await validateAccessToken(token)
				log.debug('valid token for %s', person.displayName)
			} catch (error) {
				log.error(error)
			}
		}
		beforeCommand(token, command)
		switch (command) {
		case 'create':
			return afterCommand({
				items: [await createApplication(token)],
			})
		case 'delete':
			return afterCommand({
				items: await settlePromises(args, id => confirmDELETE(token, id)),
			})
		case 'list':
			return afterCommand({
				items: await listApplications(token),
			})
		case 'login':
			if (args.length !== 2) throw new Error('missing JWT id/secret')
			return afterCommand({
				items: [
					{
						id: JSON.stringify(await loginOrApplication(token, ...args)),
						type: 'guest',
					},
				],
			})
		case 'walk':
		default:
			return afterCommand({
				items: _.get(await walkApplications(token), 'after', []),
			})
		}
	}
	const args = process.argv.slice(2)
	runCommand(DEFAULT_ACCESS_TOKEN, ...args)
		.catch((reason) => {
			process.exitCode = 1
			log.error(reason)
		})
}
